<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
<meta name="google-site-verification" content="Z6SsvW3r4WIkFz1e9zkKO2f0hFIouf3dUGoW4PNdvnI" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xxxxnnxxxx.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="xxxxnnxxxx">
<meta property="og:url" content="https://xxxxnnxxxx.github.io/index.html">
<meta property="og:site_name" content="xxxxnnxxxx">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="xxxxnnxxxx">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://xxxxnnxxxx.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>xxxxnnxxxx</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">xxxxnnxxxx</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xxxxnnxxxx.github.io/2023/07/05/%E6%A0%88%E7%9B%B8%E5%85%B3%E6%A3%80%E6%9F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xxxxnnxxxx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xxxxnnxxxx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/05/%E6%A0%88%E7%9B%B8%E5%85%B3%E6%A3%80%E6%9F%A5/" class="post-title-link" itemprop="url">栈相关检查</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-07-05 09:51:00 / Modified: 09:51:54" itemprop="dateCreated datePublished" datetime="2023-07-05T09:51:00+08:00">2023-07-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/" itemprop="url" rel="index"><span itemprop="name">杂七杂八</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-Base-Runtime-Checks-x2F-RTC1-…"><a href="#1-Base-Runtime-Checks-x2F-RTC1-…" class="headerlink" title="1. Base Runtime Checks(&#x2F;RTC1 …)"></a>1. Base Runtime Checks(&#x2F;RTC1 …)</h2><p>在vc开发程序的时候，我们在编译代码的时候，可以设置选项：<code>Base Runtime Checks</code> 如下图所示：</p>
<p><img src="./base-runtime-checks.png"><br><center>Base Runtime Checks</center></p>
<h3 id="那么什么是基础的运行时检查呢？作用是什么？"><a href="#那么什么是基础的运行时检查呢？作用是什么？" class="headerlink" title="那么什么是基础的运行时检查呢？作用是什么？"></a><b>那么什么是基础的运行时检查呢？作用是什么？</b><br></h3><p>在这个部分，我们可以查看文档 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/build/reference/rtc-run-time-error-checks?view=msvc-160">&#x2F;RTC （运行时错误检查）</a></p>
<h3 id="在汇编中，我们能看到什么？"><a href="#在汇编中，我们能看到什么？" class="headerlink" title="在汇编中，我们能看到什么？"></a><b>在汇编中，我们能看到什么？</b></h3><p><img src="./RTCfunctions.png"><br><center>RTC functions</center></p>
<h3 id="去掉RTC检查"><a href="#去掉RTC检查" class="headerlink" title="去掉RTC检查"></a><b>去掉RTC检查</b></h3><p>如下图，在选项中设置 <code>Default</code> 就可以了</p>
<img src="./no-base-runtime-checks.png">

<p>那么在汇编中，现在的情况是什么呢？</p>
<p><img src="./ida-no-base-runtime-checks.png"><br></p>
<p>我们能看到，已经没有了相关的函数，只有一个初始化和结束的函数</p>
<h2 id="2-Buffer-Security-Check-x2F-GS"><a href="#2-Buffer-Security-Check-x2F-GS" class="headerlink" title="2. Buffer Security Check(&#x2F;GS)"></a>2. Buffer Security Check(&#x2F;GS)</h2><p>检测一些缓冲区溢出，这些溢出覆盖了函数的返回地址、异常处理程序地址或某些类型的参数。导致缓冲区溢出是黑客用来利用不强制执行缓冲区大小限制的代码的一种技术。</p>
<h3 id="什么是受保护的？"><a href="#什么是受保护的？" class="headerlink" title="什么是受保护的？"></a><b>什么是受保护的？</b></h3><p>在&#x2F; GS编译器选项保护下列项目：</p>
<ul>
<li><p>函数调用的返回地址。</p>
</li>
<li><p>函数的异常处理程序的地址。</p>
</li>
<li><p>易受攻击的函数参数。</p>
</li>
</ul>
<p>在所有平台上，&#x2F;GS尝试检测缓冲区溢出到返回地址。缓冲区溢出在 x86 和 x64 等平台上更容易被利用，这些平台使用调用约定将函数调用的返回地址存储在堆栈上。</p>
<p>在 x86 上，如果函数使用异常处理程序，编译器会注入安全 cookie 以保护异常处理程序的地址。在帧展开期间检查 cookie。</p>
<p>&#x2F;GS保护传递给函数的易受攻击的参数。易受攻击的参数是指针、C++ 引用、包含指针的 C 结构（C++ POD 类型）或 GS 缓冲区。</p>
<p>在 cookie 和局部变量之前分配了一个易受攻击的参数。缓冲区溢出可以覆盖这些参数。在函数返回和执行安全检查之前，使用这些参数的函数中的代码可能会导致攻击。为了尽量减少这种危险，编译器在函数 prolog 期间制作了易受攻击的参数的副本，并将它们放在任何缓冲区的存储区域之下。</p>
<p>在以下情况下，编译器不会复制易受攻击的参数：</p>
<ul>
<li><p>不包含 GS 缓冲区的函数。</p>
</li>
<li><p>未启用优化（&#x2F;O 选项）。</p>
</li>
<li><p>具有可变参数列表 (…) 的函数。</p>
</li>
<li><p>标有裸体的函数。</p>
</li>
<li><p>在第一条语句中包含内联汇编代码的函数。</p>
</li>
<li><p>参数仅以在缓冲区溢出时不太可能被利用的方式使用。</p>
</li>
</ul>
<h3 id="什么不受保护？"><a href="#什么不受保护？" class="headerlink" title="什么不受保护？"></a><b>什么不受保护？</b></h3><p>在&#x2F;GS编译器选项并不能防止所有的缓冲区溢出的安全攻击。例如，如果对象中有一个缓冲区和一个 vtable，则缓冲区溢出可能会损坏 vtable。</p>
<p>即使您使用&#x2F;GS，也要始终尝试编写没有缓冲区溢出的安全代码。</p>
<p><i>详细的信息可以查看<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/build/reference/gs-buffer-security-check?view=msvc-160">微软官方文档</a></i></p>
<h3 id="在汇编中我们能看到什么？"><a href="#在汇编中我们能看到什么？" class="headerlink" title="在汇编中我们能看到什么？"></a><b>在汇编中我们能看到什么？</b></h3><p><img src="./buffersecuritycheck.png"><br><center>Buffer Security Check</center></p>
<h2 id="3-Buffer-Security-Check原理"><a href="#3-Buffer-Security-Check原理" class="headerlink" title="3. Buffer Security Check原理"></a>3. Buffer Security Check原理</h2><p>我们在IDA 中查看反编译汇编代码，如下图：</p>
<p><img src="./asm-buffersercuritycheck.png"><br/></p>
<p>观看以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var_4= dword ptr -4</span><br><span class="line"></span><br><span class="line">push    ebp</span><br><span class="line">mov     ebp, esp</span><br><span class="line">sub     esp, 70h</span><br><span class="line">mov     eax, ___security_cookie</span><br><span class="line">xor     eax, ebp</span><br><span class="line">mov     [ebp+var_4], eax</span><br></pre></td></tr></table></figure>
<p>其中 <code>___security_cookie</code> 是一个固定值,如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">___security_cookie dd 0BB40E64Eh</span><br></pre></td></tr></table></figure>

<p>在函数结束位置，我们看到如下汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov     ecx, [ebp+var_4]</span><br><span class="line">xor     ecx, ebp        ; cookie</span><br><span class="line">call    j_@__security_check_cookie@4 ; __security_check_cookie(x)</span><br></pre></td></tr></table></figure>
<p>我们查看 <code>__security_check_cookie(x)</code> 函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">; void __fastcall __security_check_cookie(unsigned int cookie)</span><br><span class="line">.text:00411310 @__security_check_cookie@4 proc near    ; CODE XREF: __security_check_cookie(x)j</span><br><span class="line">.text:00411310</span><br><span class="line">.text:00411310 cookie          = dword ptr -4</span><br><span class="line">.text:00411310</span><br><span class="line">.text:00411310                 cmp     ecx, ___security_cookie</span><br><span class="line">.text:00411316                 jnz     short failure</span><br><span class="line">.text:00411318                 rep retn</span><br><span class="line">.text:0041131A ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0041131A</span><br><span class="line">.text:0041131A failure:                                ; CODE XREF: __security_check_cookie(x)+6j</span><br><span class="line">.text:0041131A                 jmp     j____report_gsfailure</span><br><span class="line">.text:0041131A @__security_check_cookie@4 endp</span><br></pre></td></tr></table></figure>

<p>我们比较上面的内容发现，如果在使用过程中，变量改变了，那么就出现错误。所以这样就保证了缓存区溢出造成的漏洞。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>目录projects 下有功能 test_safeSEH 和 testc_bufcheck</li>
</ol>
<h2 id="3-x2F-JMC-CheckForDebuggerJustMyCode-4-选项"><a href="#3-x2F-JMC-CheckForDebuggerJustMyCode-4-选项" class="headerlink" title="3. &#x2F;JMC (@__CheckForDebuggerJustMyCode@4) 选项"></a>3. &#x2F;JMC (@__CheckForDebuggerJustMyCode@4) 选项</h2><p>微软官方文档：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/cpp/build/reference/jmc?view=msvc-170">https://learn.microsoft.com/en-us/cpp/build/reference/jmc?view=msvc-170</a></p>
<p>指定编译器支持 Visual Studio 调试器中的本机 Just My Code 调试。此选项支持允许 Visual Studio 跨过系统、框架、库和其他非用户调用并在调用堆栈窗口中折叠这些调用的用户设置。 &#x2F;JMC 编译器选项从 Visual Studio 2017 版本 15.8 开始可用。</p>
<p>选项位置：</p>
<p><img src="/2023/07/05/%E6%A0%88%E7%9B%B8%E5%85%B3%E6%A3%80%E6%9F%A5/jmc.png"></p>
<p>启用 &#x2F;JMC 时，编译器会在函数序言中插入对辅助函数 <code>__CheckForDebuggerJustMyCode</code> 的调用。帮助函数提供支持 Visual Studio 调试器 Just My Code 步骤操作的挂钩。</p>
<p>如果启用了 <code>/JMC</code> 通过反汇编，可以查看如下代码：</p>
<p><img src="/2023/07/05/%E6%A0%88%E7%9B%B8%E5%85%B3%E6%A3%80%E6%9F%A5/jmc2.png"></p>
<p>启用 <code>/JMC</code> 选项后，PDB 文件会使用额外的行号信息进行注释。在 Visual Studio 2019 版本 16.8 之前的版本中，此信息可能会出现在代码覆盖率报告中，出现在第 15732480 (0xF00F00) 行或 16707566 (0xFEEFEE) 行。这些虚构的行号用作区分用户代码和非用户代码的标记。要在没有这些意外行号的情况下在代码覆盖率报告中包含非用户代码，请使用 <code>/JMC-</code> 选项构建您的代码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xxxxnnxxxx.github.io/2023/07/04/CVE-2023-21768/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="xxxxnnxxxx">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xxxxnnxxxx">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/04/CVE-2023-21768/" class="post-title-link" itemprop="url">星期二补丁- 星期三利用：24 小时内破解 WinSock (afd.sys) 的 Windows 辅助功能驱动程序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-07-04 22:16:00 / Modified: 22:48:51" itemprop="dateCreated datePublished" datetime="2023-07-04T22:16:00+08:00">2023-07-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/" itemprop="url" rel="index"><span itemprop="name">杂七杂八</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <style>
.highlight {
    background-color: rgba(23, 200, 150, 0.5);
}
</style>

<p>原文地址：<a target="_blank" rel="noopener" href="https://securityintelligence.com/posts/patch-tuesday-exploit-wednesday-pwning-windows-ancillary-function-driver-winsock/">Patch Tuesday -&gt; Exploit Wednesday: Pwning Windows Ancillary Function Driver for WinSock (afd.sys) in 24 Hours</a></p>
<p>“星期二补丁，星期三利用” 是一句古老的黑客格言，指的是每月安全补丁公开后的第二天，漏洞就被武器化。随着安全性的提高和漏洞缓解措施变得更加复杂，制作武器化漏洞所需的研究和开发量也随之增加。这与内存损坏漏洞尤其相关。</p>
<p><img src="/2023/07/04/CVE-2023-21768/p0.png"></p>
<p>然而，随着 Windows 11 内核中添加新功能（以及内存不安全的 C 代码），可能会引入成熟的新攻击面。通过研究这个新引入的代码，我们证明了可以轻易武器化的漏洞仍然经常发生。在这篇博文中，我们分析并利用了 Winsock 的 Windows 辅助功能驱动程序 <code>afd.sys</code> 中的一个漏洞，用于 Windows 11 上的本地权限升级 (LPE)。虽然我们之前都没有使用此内核模块的经验，但我们能够在大约一天内诊断、重现该漏洞并将其武器化。您可以在 [此处] (<a target="_blank" rel="noopener" href="https://github.com/xforcered/Windows_LPE_AFD_CVE-2023-21768)%E6%89%BE%E5%88%B0%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%BB%A3%E7%A0%81%E3%80%82">https://github.com/xforcered/Windows_LPE_AFD_CVE-2023-21768)找到漏洞利用代码。</a></p>
<h2 id="补丁差异和根本原因分析"><a href="#补丁差异和根本原因分析" class="headerlink" title="补丁差异和根本原因分析"></a><strong>补丁差异和根本原因分析</strong></h2><p>根据微软安全响应中心（MSRC）发布的CVE-2023-21768的详细信息，该漏洞存在于辅助功能驱动程序（AFD）中，其二进制文件名为 <code>afd.sys</code>。AFD 模块是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Winsock">Winsock API</a> 的内核入口点。利用这些信息，我们分析了 2022 年 12 月的驱动程序版本，并将其与 2023 年 1 月新发布的版本进行了比较。这些样本可以从 <a target="_blank" rel="noopener" href="https://winbindex.m417z.com/">Winbindex</a> 单独获取，无需从 Microsoft 补丁中提取更改的耗时过程。分析的两个版本如下所示。</p>
<ul>
<li>AFD.sys &#x2F; Windows 11 22H2 &#x2F; 10.0.22621.608 (December 2022)</li>
<li>AFD.sys &#x2F; Windows 11 22H2 &#x2F; 10.0.22621.1105 (January 2023)</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://ghidra-sre.org/">Ghidra</a> 用于为这两个文件创建二进制导出，以便可以在 <a target="_blank" rel="noopener" href="https://www.zynamics.com/bindiff.html">BinDiff</a> 中对它们进行比较。匹配功能的概述如下所示。</p>
<p><img src="/2023/07/04/CVE-2023-21768/p1.png"></p>
<center>Figure 2 — Binary comparison of AFD.sys</center>

<p>似乎只有一个函数发生了变化，<code>afd!AfdNotifyRemoveIoCompletion</code>。这大大加快了我们对漏洞的分析速度。然后我们比较了这两个功能。下面的屏幕截图显示了在 <a target="_blank" rel="noopener" href="https://binary.ninja/">Binary Ninja</a> 中查看反编译代码时修补前后代码的变化。</p>
<p><strong>Pre-patch</strong>, <code>afd.sys version 10.0.22621.608</code>.</p>
<p><img src="/2023/07/04/CVE-2023-21768/p2.png"></p>
<center>Figure 3 — afd!AfdNotifyRemoveIoCompletion pre-patch</center>

<p><strong>Post-patch</strong>, <code>afd.sys version 10.0.22621.1105</code>.</p>
<p><img src="/2023/07/04/CVE-2023-21768/p3.png"></p>
<center>Figure 4 — afd!AfdNotifyRemoveIoCompletion post-patch</center>

<p>上面显示的此更改是对已识别功能的唯一更新。一些快速分析表明，正在根据以下内容执行检查</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/previousmode">PreviousMode</a> 。 如果 <code>PreviousMode</code> 为 0 （表明调用源自内核），则将值写入由未知结构中的字段指定的指针。另一方面，如果 PreviousMode 不为零，则 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-probeforwrite">ProbeForWrite</a>函数被调用确保该字段中设置的指针是驻留在用户模式中的有效地址。</p>
<p>补丁前版本的驱动程序中缺少此检查。由于该函数有一个针对 <code>PreviousMode</code> 的特定 switch 语句，因此假设开发人员打算添加此检查但忘记了（我们有时都缺咖啡☕！）。</p>
<p>从这次更新中，我们可以推断攻击者可以通过未知结构的 <code>field_0x18</code> 处的受控值到达此代码路径。如果攻击者能够使用内核地址填充此字段，则可以创建任意内核 Write-Where 原语。此时，尚不清楚正在写入什么值，但任何值都可能用于本地权限升级原语。</p>
<p>函数原型本身包含 <code>PreviousMode</code> 值和指向未知结构的指针，分别作为第一个和第三个参数。</p>
<p><img src="/2023/07/04/CVE-2023-21768/p4.png"></p>
<center>Figure 5 — afd!AfdNotifyRemoveIoCompletion function prototype</center>

<h2 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a><strong>逆向工程</strong></h2><p>我们现在知道漏洞的位置，但不知道如何触发有漏洞的代码路径的执行。在开始进行概念验证 (PoC) 之前，我们将进行一些逆向工程。</p>
<p>首先，交叉引用易受攻击的函数以了解其使用地点和方式。</p>
<p><img src="/2023/07/04/CVE-2023-21768/p5.png"></p>
<p>在 <code>afd!AfdNotifySock</code> 中对易受攻击的函数进行了一次调用。</p>
<p>我们重复该过程，寻找对 <code>AfdNotifySock</code> 的交叉引用。我们发现没有对该函数的直接调用，但其地址出现在名为 <code>AfdIrpCallDispatch</code> 的函数指针表上方。</p>
<p><img src="/2023/07/04/CVE-2023-21768/p6.png"></p>
<center>Figure 7 — afd!AfdIrpCallDispatch</center>

<p>该表包含 AFD 驱动程序的调度例程。调度例程用于通过调用来处理来自 Win32 应用程序的请求 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a>. 每个函数的控制代码可在 <code>AfdIoctlTable</code> 中找到。</p>
<p>然而，上面的指针并不像我们预期的那样位于 <code>AfdIrpCallDispatch</code> 表中。从 Steven Vittitoe 的 <a target="_blank" rel="noopener" href="https://recon.cx/2015/slides/recon2015-20-steven-vittitoe-Reverse-Engineering-Windows-AFD-sys.pdf">Recon</a> 谈话幻灯片中，我们发现 AFD 实际上有两个调度表。第二个是 <code>AfdImmediateCallDispatch</code> 。通过计算该表的开头与存储 AfdNotifySock 的指针之间的距离，我们可以计算 AfdIoctlTable 的索引，该索引显示该函数的控制代码是 <code>0x12127</code>。</p>
<p><img src="/2023/07/04/CVE-2023-21768/p7.png"></p>
<center>Figure 8 — afd!AfdIoctlTable</center>

<p>值得注意的是，它是表中最后一个输入&#x2F;输出控制（IOCTL）代码，表明 <code>AfdNotifySock</code> 很可能是最近添加到 AFD 驱动程序中的新调度函数。</p>
<p>此时，我们有几个选择。我们可以在用户空间对相应的 <code>Winsock API</code> 进行逆向工程，以更好地了解底层内核函数是如何调用的，或者对内核代码进行逆向工程并直接调用它。我们实际上并不知道哪个 Winsock 函数对应于 <code>AfdNotifySock</code> ，因此我们选择了后者。</p>
<p>我们发现 <a target="_blank" rel="noopener" href="https://twitter.com/x86matthew">x86matthew</a> 发布的一些<a target="_blank" rel="noopener" href="https://www.x86matthew.com/view_post?id=ntsockets">代码</a>通过直接调用 AFD 驱动程序来执行套接字操作，放弃了 Winsock 库。从隐秘的角度来看，这很有趣，但就我们的目的而言，它是一个很好的模板，可以创建 TCP 套接字的句柄以向 AFD 驱动程序发出 IOCTL 请求。从那里，我们能够到达目标函数，正如在内核调试时到达 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools">WinDbg</a> 中设置的断点所证明的那样。</p>
<p><img src="/2023/07/04/CVE-2023-21768/p8.png"></p>
<center>Figure 9 — afd!AfdNotifySock breakpoint</center>

<p>现在，回顾一下 <code>DeviceIoControl</code> 的函数原型，通过它我们从用户空间调用 AFD 驱动程序。参数之一 lpInBuffer 是用户模式缓冲区。如上一节所述，该漏洞的发生是因为用户能够在未知数据结构中将未经验证的指针传递给驱动程序。该结构是通过 <code>lpInBuffer</code> 参数直接从我们的用户模式应用程序传入的。它作为第四个参数传递到 AfdNotifySock 中，并作为第三个参数传递到 <code>AfdNotifyRemoveIoCompletion</code> 中。</p>
<p>此时，我们不知道如何填充 <code>lpInBuffer</code> 中的数据（我们将其称为 <code>AFD_NOTIFYSOCK_STRUCT</code> ），以便通过到达 <code>AfdNotifyRemoveIoCompletion</code> 中易受攻击的代码路径所需的检查。我们逆向工程过程的其余部分包括遵循执行流程并检查如何访问易受攻击的代码。</p>
<p>让我们逐一检查一下。</p>
<p>我们遇到的第一个检查是在 <code>AfdNotifySock</code> 的开头：</p>
<p><img src="/2023/07/04/CVE-2023-21768/p9.png"></p>
<center>Figure 10 — afd!AfdNotifySock size check</center>

<p>此检查告诉我们 <code>AFD_NOTIFYSOCK_STRUCT</code> 的大小应等于 0x30 字节，否则函数会失败并显示 <code>STATUS_INFO_LENGTH_MISMATCH</code> 。</p>
<p>下一个检查验证结构中各个字段中的值：</p>
<p><img src="/2023/07/04/CVE-2023-21768/p10.png"></p>
<center>Figure 11 — afd!AfdNotifySock structure validation</center>

<p>当时我们不知道这些字段对应什么，所以我们传入一个 <code>0x30</code> 字节数组，其中填充了 <code>0x41</code> 字节（AAAAAAAAA…）。</p>
<p>我们遇到的下一个检查是在调用之后 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-obreferenceobjectbyhandle">ObReferenceObjectByHandle</a>. 该函数将输入结构的第一个字段作为其第一个参数。</p>
<p><img src="/2023/07/04/CVE-2023-21768/p11.png"></p>
<center>Figure 12 — afd!AfdNotifySock call nt!ObReferenceObjectByHandle</center>

<p>该调用必须返回成功才能继续到正确的代码执行路径，这意味着我们必须将有效的句柄传递给 <code>IoCompletionObject</code> 。没有正式记录的方法可以通过 Win32 API 创建该类型的对象。然而，经过一番搜索，我们发现了一个未记录的 NT 函数 <a target="_blank" rel="noopener" href="http://undocumented.ntinternals.net/index.html?page=UserMode/Undocumented%20Functions/NT%20Objects/IoCompletion/NtCreateIoCompletion.html">NtCreateIoCompletion</a> 之后，我们到达一个循环，其计数器是结构中的值之一：</p>
<p><img src="/2023/07/04/CVE-2023-21768/p12.png"></p>
<center>Figure 13 — afd!AfdNotifySock loop</center>

<p>该循环检查结构中的一个字段，以验证它包含有效的用户模式指针并将数据复制到其中。每次循环迭代后指针都会递增。我们用有效地址填充了指针，并将计数器设置为 1。从这里，我们最终能够到达存在漏洞的函数 <code>AfdNotifyRemoveIoCompletion</code> 。</p>
<p><img src="/2023/07/04/CVE-2023-21768/p13.png"></p>
<center>Figure 14 — afd!AfdNotifyRemoveIoCompletion call</center>

<p>进入 <code>AfdNotifyRemoveIoCompletion</code> 后，第一个检查是结构中的另一个字段。它必须是非零的。然后将其乘以 0x20，并与结构体中的另一个字段一起作为指针参数传递到 <code>ProbeForWrite</code> 。从这里，我们可以使用有效的用户模式指针 (<code>pData2</code>) 和字段 <code>dwLen = 1</code> 进一步填充结构（以便传递给 <code>ProbeForWrite</code> 的总大小等于 <code>0x20</code> ），并且检查通过。</p>
<p><img src="/2023/07/04/CVE-2023-21768/p14.png"></p>
<center>Figure 15 — afd! Afd!AfdNotifyRemoveIoCompletion field check</center>

<p>最后，在到达目标代码之前要通过的最后一个检查是对 <code>IoRemoveCompletion</code> 的调用，它必须返回 0 (<code>STATUS_SUCCESS</code>)。</p>
<p>该函数将阻塞，直到：</p>
<ul>
<li><p>完成记录可用于 <code>IoCompletionObject</code> 参数</p>
</li>
<li><p>超时到期，作为函数的参数传入</p>
</li>
</ul>
<p>我们通过结构控制超时值，但简单地将超时设置为 0 不足以让函数返回成功。为了使该函数无错误地返回，必须至少有一个可用的完成记录。经过一番研究，我们发现了未记录的功能 <a target="_blank" rel="noopener" href="http://undocumented.ntinternals.net/index.html?page=UserMode/Undocumented%20Functions/NT%20Objects/IoCompletion/NtSetIoCompletion.html">NtSetIoCompletion</a> 它手动增加 <code>IoCompletionObject</code> 上的 I&#x2F;O 挂起计数器。在我们之前创建的 <code>IoCompletionObject</code> 上调用此函数可确保对 <code>IoRemoveCompletion</code> 的调用返回 <code>STATUS_SUCCESS</code> 。</p>
<p><img src="/2023/07/04/CVE-2023-21768/p15.png"></p>
<center>Figure 16 — afd!AfdNotifyRemoveIoCompletion check return nt!IoRemoveIoCompletion</center>

<h2 id="触发任意写位置"><a href="#触发任意写位置" class="headerlink" title="触发任意写位置"></a><strong>触发任意写位置</strong></h2><p>现在我们可以到达易受攻击的代码，我们可以用任意要写入的地址填充结构中的适当字段。我们写入该地址的值来自一个整数，该整数的指针被传递到对 <code>IoRemoveIoCompletion</code> 的调用中。 <code>IoRemoveIoCompletion</code> 将此整数的值设置为调用 <code>KeRemoveQueueEx</code> 的返回值。</p>
<p><img src="/2023/07/04/CVE-2023-21768/p16.png"></p>
<center>Figure 17 — nt!KeRemoveQueueEx return value</center>

<p><img src="/2023/07/04/CVE-2023-21768/p17.png"></p>
<center>Figure 18 — nt!KeRemoveQueueEx return use</center>

<p>在我们的概念验证中，该写入值始终等于 0x1。我们推测 <code>KeRemoveQueueEx</code> 的返回值是从队列中删除的项目数，但没有进一步调查。此时，我们已经有了所需的原语，并继续完成漏洞利用链。我们后来证实了这个猜测是正确的，并且可以通过对 <code>IoCompletionObject</code> 上的 <code>NtSetIoCompletion</code> 进行额外调用来任意增加写入值。</p>
<h2 id="LPE-with-IORING"><a href="#LPE-with-IORING" class="headerlink" title="LPE with IORING"></a><strong>LPE with IORING</strong></h2><p>由于能够在任意内核地址写入固定值 (0x1)，我们继续将其转换为完整的任意内核读&#x2F;写。由于此漏洞影响最新版本的 Windows 11(<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/release-health/windows11-release-information">22H2</a>)，因此我们选择利用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/ioringapi/">Windows I&#x2F;O</a> 环对象损坏来创建我们的原语。<a target="_blank" rel="noopener" href="https://twitter.com/yarden_shafir">Yarden Shafir</a> 撰写了许多关于 Windows I&#x2F;O 环的优秀文章，并且还开发并披露了我们在漏洞利用链中利用的<a target="_blank" rel="noopener" href="https://windows-internals.com/one-i-o-ring-to-rule-them-all-a-full-read-write-exploit-primitive-on-windows-11/">原语</a>。据我们所知，这是该原语首次被用于公共漏洞利用。<span class="highlight"> 当用户初始化 I&#x2F;O 环时，会创建两个独立的结构，一个在用户空间，一个在内核空间。</span> 这些结构如下所示。</p>
<p>内核对象映射到 <code>nt!_IORING_OBJECT</code>，如下所示。</p>
<p><img src="/2023/07/04/CVE-2023-21768/p18.png"></p>
<center>Figure 19 — nt!_IORING_OBJECT initialization</center>

<p>请注意，内核对象有两个字段：<code>RegBuffersCount</code> 和 <code>RegBuffers</code>，它们在初始化时被清零。该计数指示有多少 I&#x2F;O 操作可以在 I&#x2F;O 环中排队。另一个参数是指向当前排队操作列表的指针。</p>
<p>在用户空间端，调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/ioringapi/nf-ioringapi-createioring">kernelbase!CreateIoRing</a>时，如果成功，您将返回一个 I&#x2F;O 环句柄。该句柄是指向未记录结构 (<code>HIORING</code>) 的指针。我们对这种结构的定义是从 Yarden Shafir 所做的研究中获得的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">HIORING</span> &#123;</span></span><br><span class="line">    HANDLE handle;</span><br><span class="line">    NT_IORING_INFO Info;</span><br><span class="line">    ULONG IoRingKernelAcceptedVersion;</span><br><span class="line">    PVOID RegBufferArray;</span><br><span class="line">    ULONG BufferArraySize;</span><br><span class="line">    PVOID Unknown;</span><br><span class="line">    ULONG FileHandlesCount;</span><br><span class="line">    ULONG SubQueueHead;</span><br><span class="line">    ULONG SubQueueTail;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果某个漏洞（例如本博文中提到的漏洞）允许您更新 <code>RegBuffersCount</code> 和 <code>RegBuffers</code> 字段，则可以使用标准 I&#x2F;O Ring API 来读取和写入内核内存。</p>
<p>正如我们在上面看到的，我们可以利用该漏洞在我们喜欢的任何内核地址写入 <code>0x1</code>。要设置 I&#x2F;O 环原语，我们只需触发该漏洞两次即可。</p>
<p><img src="/2023/07/04/CVE-2023-21768/p19.png"></p>
<center>Figure 20 — nt!_IORING_OBJECT first time triggering the bug</center>

<p>在第二个触发器中，我们将 <code>RegBuffers</code> 设置为可以在用户空间中分配的地址（例如 <code>0x0000000100000000</code>）。</p>
<p><img src="/2023/07/04/CVE-2023-21768/p20.png"></p>
<center>Figure 21 — nt!_IORING_OBJECT second time triggering the bug</center>

<p><span class="highlight">备注：</span> 需要验证两次的原因就是 <code>RegBuffersCount</code> 和 <code>RegBuffers</code> 分别验证是否能通过带有缺陷的驱动写入。</p>
<p>剩下的就是通过在用户空间地址 (<code>0x100000000</code>) 写入伪造的 <code>nt!_IOP_MC_BUFFER_ENTRY</code> 结构的指针来对 I&#x2F;O 操作进行排队。条目数应等于 <code>RegBuffersCount</code> 。下图中突出显示了此过程。</p>
<p><img src="/2023/07/04/CVE-2023-21768/p21.png"></p>
<center>Figure 22 — Setting up user space for I/O Ring kernel R/W primitive</center>

<p>下面的屏幕截图显示了这样一个 <code>nt!_IOP_MC_BUFFER_ENTRY</code> 。请注意，操作的目标是内核地址 (<code>0xfffff8052831da20</code>)，并且在本例中操作的大小为 <code>0x8</code> 字节。从结构中无法判断这是读操作还是写操作。操作的方向取决于使用哪个 API 对 I&#x2F;O 请求进行排队。利用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/ioringapi/nf-ioringapi-buildioringreadfile">kernelbase!BuildIoRingReadFile</a> 导致任意内核写入，<code>kernelbase!BuildIoRingWriteFile</code> 导致任意内核读取。</p>
<p><img src="/2023/07/04/CVE-2023-21768/p22.png"></p>
<center>Figure 23 — Example faked I/O Ring operation</center>

<p>为了执行任意写入，I&#x2F;O 操作的任务是从文件句柄读取数据并将该数据写入内核地址。</p>
<p><img src="/2023/07/04/CVE-2023-21768/p23.png"></p>
<center>Figure 24 — I/O Ring arbitrary write</center>

<p>相反，为了执行任意读取，I&#x2F;O 操作的任务是读取内核地址处的数据并将该数据写入文件句柄。</p>
<p><img src="/2023/07/04/CVE-2023-21768/p24.png"></p>
<center>Figure 25 – I/O Ring arbitrary read</center>

<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a><strong>Demo</strong></h2><p>设置原语后，剩下的就是使用一些标准内核后利用技术来泄漏系统（PID 4）等提升进程的令牌并覆盖不同进程的令牌。</p>
<p><a target="_blank" rel="noopener" href="https://youtu.be/M3IPsKAsxvQ">Exploiting Windows 11 with Ancillary Function Driver vulnerability CVE-2023-21768</a></p>
<p><img src="/2023/07/04/CVE-2023-21768/p25.png"></p>
<h2 id="在野利用"><a href="#在野利用" class="headerlink" title="在野利用"></a><strong>在野利用</strong></h2><p>在我们的漏洞<a target="_blank" rel="noopener" href="https://github.com/xforcered/Windows_LPE_AFD_CVE-2023-21768">代码</a>公开后，来自360 Icesword Lab的Xiaoliang Liu（<a target="_blank" rel="noopener" href="https://twitter.com/flame36987044">@flame36987044</a>）首次公开披露，他们在今年早些时候发现了利用该漏洞的样本（ITW）。 ITW 样本使用的技术与我们的不同。攻击者使用相应的 Winsock API 函数 <code>ProcessSocketNotifications</code> 触发漏洞，而不是像我们的漏洞利用那样直接调用 afd.sys 驱动程序。</p>
<p>360冰剑实验室官方声明如下：</p>
<p>“360冰剑实验室专注于APT检测与防御。基于我们的0day漏洞雷达系统，今年1月份我们在野外发现了CVE-2023-21768的利用样本，该样本与 <a target="_blank" rel="noopener" href="https://twitter.com/chompie1337">@chompie1337</a> 和 <a target="_blank" rel="noopener" href="https://twitter.com/FuzzySec">@FuzzySec</a> 公布的利用样本不同，它是通过系统机制和漏洞特征进行利用的。该漏洞与 <code>NtSetIoCompletion</code> 和 <code>ProcessSocketNotifications</code> 有关， <code>ProcessSocketNotifications</code> 获取调用 <code>NtSetIoCompletion</code> 的次数，因此我们使用它来更改权限计数。”</p>
<h2 id="结论和最终反思"><a href="#结论和最终反思" class="headerlink" title="结论和最终反思"></a>结论和最终反思</h2><p>您可能会注意到，在逆向工程的某些部分，我们的分析是肤浅的。有时，仅观察一些相关的状态变化并将程序的某些部分视为黑匣子是有帮助的，以避免陷入不相关的兔子洞。这使我们能够快速扭转漏洞，尽管最大化完成速度不是我们的目标。此外，我们对 afd.sys 中所有报告的漏洞进行了补丁差异审查，这些漏洞被标记为“利用可能性更大”。我们的审查显示，除了两个漏洞之外，所有漏洞都是由于对从用户模式传入的指针验证不当造成的。这表明，了解过去的漏洞（尤其是特定目标内的漏洞）的历史知识，对于发现新漏洞可能会卓有成效。当代码库扩展时，同样的错误很可能会重复。请记住，新的 C 代码 &#x3D;&#x3D; 新的 bug 😀。正如发现上述漏洞在野外被利用所证明的那样，可以肯定地说，攻击者也在密切监视新的代码库添加。</p>
<p>Windows 内核中缺乏对管理员模式访问保护 (SMAP) 的支持，这给我们提供了丰富的选项来构建新的纯数据利用原语。这些原语在支持 SMAP 的其他操作系统中不可行。例如，考虑 CVE-2021-41073，这是 Linux 的 I&#x2F;O 环预注册缓冲区实现中的一个漏洞（我们在 Windows 中滥用相同的功能用于 R&#x2F;W 原语）。此漏洞可以允许覆盖已注册缓冲区的内核指针，但不能用于构造任意 R&#x2F;W 原语，因为如果该指针被替换为用户指针，并且内核尝试在那里读取或写入，系统将崩溃。</p>
<p>尽管微软尽了最大努力来消除人们喜爱的<a target="_blank" rel="noopener" href="https://twitter.com/33y0re/status/1597640404748599296">漏洞利用原语</a>，但肯定会发现新的原语来取代它们。我们能够利用最新版本的 Windows 11 22H2，而不会遇到 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/bringup/device-guard-and-credential-guard">HVCI(内存完整性和基于虚拟化的安全性)</a> 等基于虚拟化的安全功能的任何缓解或限制。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a target="_blank" rel="noopener" href="https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2023-21768">MSRC (CVE-2023-21768)</a></li>
<li><a target="_blank" rel="noopener" href="https://windows-internals.com/i-o-rings-when-one-i-o-operation-is-not-enough/">I&#x2F;O Rings – When One I&#x2F;O Operation is Not Enough  (@yarden_shafir)</a></li>
<li><a target="_blank" rel="noopener" href="https://windows-internals.com/ioring-vs-io_uring-a-comparison-of-windows-and-linux-implementations/">IoRing vs. io_uring: a comparison of Windows and Linux implementations  (@yarden_shafir)</a></li>
<li><a target="_blank" rel="noopener" href="https://windows-internals.com/one-year-to-i-o-ring-what-changed/">One Year to I&#x2F;O Ring: What Changed? (@yarden_shafir)</a></li>
<li><a target="_blank" rel="noopener" href="https://windows-internals.com/one-i-o-ring-to-rule-them-all-a-full-read-write-exploit-primitive-on-windows-11/">One I&#x2F;O Ring to Rule Them All: A Full Read&#x2F;Write Exploit Primitive on Windows 11 (@yarden_shafir)</a></li>
<li><a target="_blank" rel="noopener" href="https://knifecoat.com/Posts/Arbitrary+Kernel+RW+using+IORING's">Arbitrary Kernel RW using IORING’s (@FuzzySec)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.x86matthew.com/view_post?id=ntsockets">NTSockets – Downloading a file via HTTP using the NtCreateFile and NtDeviceIoControlFile syscalls (@x86matthew)</a></li>
<li><a target="_blank" rel="noopener" href="https://recon.cx/2015/slides/recon2015-20-steven-vittitoe-Reverse-Engineering-Windows-AFD-sys.pdf">Reverse Engineering AFD.sys (@bool101)</a></li>
<li><a target="_blank" rel="noopener" href="https://exchange.xforce.ibmcloud.com/vulnerabilities/243235">Microsoft Windows Ancillary Function Driver for WinSock privilege escalation CVE-2023-21768 Vulnerability Report</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">xxxxnnxxxx</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xxxxnnxxxx</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
